#version 450

//常量
float PI = 3.1415926535f;

//struct
//现在就一个pos，但是以后需要采样texture时或者别的时候可以再加
struct Vertex {
	vec4 pos;
	vec4 normal;
};

struct Light {
	vec4 lightPos_strength;
	vec4 normal_randomNumber;
	vec4 size;
};

struct AABBBox {
	float leftX;
	float rightX;
	float leftY;
	float rightY;
	float leftZ;
	float rightZ;
};

struct BvhArrayNode {
	int leftNodeIndex;
	int rightNodeIndex;
	AABBBox AABB;
	int meshIndex;
};

struct Material {
	vec4 ka;
	vec4 kd;
	vec4 ks;
	vec4 ke;
};

struct Mesh {
	Material material;
	ivec2 indexInIndicesArray;
	AABBBox AABB;
};

struct Ray{
	vec3 startPoint;
	vec3 direction;
	vec3 normal;	//这个主要是记录上一个着色点的法线
	//vec3 radiance;
	float depth;
};

layout(set = 0, binding = 0) uniform LightUniformBufferObject {
	mat4 model;
	mat4 view;
	mat4 proj;
	Light light;
	vec4 cameraPos;
} lubo;

layout(set = 1, binding = 0) uniform cameraUniformBufferObject {
	mat4 model;
	mat4 view;
	mat4 proj;
	Light light;
	vec4 cameraPos;
} cubo;
layout(set = 2, binding = 0, std430) readonly buffer BvhArray{
	BvhArrayNode bvhArrayNode[];
};
layout(set = 2, binding = 1, std430) readonly buffer Vertices{
	Vertex vertices[]; 
};
layout(set = 2, binding = 2, std430) readonly buffer Indices{
	uint indices[]; 
};
layout(set = 2, binding = 3, std430) readonly buffer Meshs{
	Mesh meshs[]; 
};

layout(set = 2, binding = 4) uniform sampler2D shadowMap;
layout(set = 2, binding = 5, rgba8) uniform writeonly image2D pathTracingResult;

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

//function
//创造射线
Ray makeStartRay(vec2 texelUV){

	vec4 ndcPos = vec4(texelUV * 2.0f - 1.0f, 0.0f, 1.0f);
	vec4 worldPos = inverse(cubo.proj * cubo.view) * ndcPos;
	Ray ray;
	ray.startPoint = cubo.cameraPos.xyz;
	ray.direction = normalize((worldPos.xyz / worldPos.w) - ray.startPoint);	//得到的worldPos是近平面的一点
	ray.normal = ray.direction;//normalize(transpose(mat3(cubo.view)) * vec3(0.0f, 0.0f, -1.0f));	//逆矩阵的转置的逆 = 转置 
	ray.depth = 100;	//远平面

	return ray;

}

uint pcg(inout uint state)
{
    uint prev = state * 747796405u + 2891336453u;
    uint word = ((prev >> ((prev >> 28u) + 4u)) ^ prev) * 277803737u;
    state = prev;
    return (word >> 22u) ^ word;
}

uvec2 pcg2d(uvec2 v)
{
    v = v * 1664525u + 1013904223u;
    v.x += v.y * 1664525u;
    v.y += v.x * 1664525u;
    v = v ^ (v >> 16u);
    v.x += v.y * 1664525u;
    v.y += v.x * 1664525u;
    v = v ^ (v >> 16u);
    return v;
}

float rand(inout uint seed)
{
    uint val = pcg(seed);
    return (float(val) * (1.0 / float(0xffffffffu)));
}


//低差异序列
float RadicalInverse_VdC(uint bits) 
{
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10; // / 0x100000000
}
vec2 Hammersley(uint i, uint N)
{
    return vec2(float(i)/float(N), RadicalInverse_VdC(i));
}  

//需要材质、TBN
vec4 getRayDirection(Material material, mat3 TBN, float randomNumber){

	//vec2 randomNumber = Hammersley(uint(rand(randomNumberSeed) * 100), 100);
	//vec2 randomNumber = vec2(rand(randomNumberSeed), rand(randomNumberSeed));
	vec2 randomNumberH = Hammersley(uint(randomNumber * 100), 100);

	float sinTheta = sqrt(1 - randomNumberH.x * randomNumberH.x);
	float cosTheta = randomNumberH.x;
	float phi = 2 * PI * randomNumberH.y;
	vec3 rayDirection = normalize(vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta));
	return vec4(normalize(TBN * rayDirection), 1 / (2 * PI));

}

//AABB碰撞检测，-1表示没有碰撞到，0表示碰撞到了且不是在场景内部，1表示在场景内部
bool hitAABB(AABBBox AABB, Ray ray){

	//这里并不能检测出是否朝向AABB，反而会导致原本该命中的被剔除了，尤其是有些vertex，其发射方向与AABB中心除以一个夹角，导致只有与夹角小于90度的地方才能命中
	//vec3 AABBCenter = vec3(AABB.leftX + (AABB.rightX - AABB.leftX) / 2, 
	//					   AABB.leftY + (AABB.rightY - AABB.leftY) / 2,
	//					   AABB.leftZ + (AABB.rightZ - AABB.leftZ) / 2);
	////判断ray的方向是否朝向AABB，并且不能射向发射点的AABB
	//if(dot(AABBCenter - ray.startPoint, ray.direction) <= 0.0f){
	//	return false;
	//}
	
	//判断光线是不是在场景内部发出的，如果是还不能直接抛弃别的场景
	//虽然会导致每次都与自身发射点的AABB再检测一次hitMesh
	if(ray.startPoint.x > AABB.leftX && ray.startPoint.x < AABB.rightX && 
	   ray.startPoint.y > AABB.leftY && ray.startPoint.y < AABB.rightY &&
	   ray.startPoint.z > AABB.leftZ && ray.startPoint.z < AABB.rightZ){
		return true;
	}

	float maxInTime = 0.0f;
	float minOutTime = 1000000.0f;	//超了再说

	if(ray.direction.x != 0){	//直射与面都不考虑
		float leftX = (AABB.leftX - ray.startPoint.x) / ray.direction.x;
		float rightX= (AABB.rightX - ray.startPoint.x) / ray.direction.x;
		maxInTime = max(min(leftX, rightX), maxInTime);
		minOutTime = min(max(leftX, rightX), minOutTime);
	}

	if(ray.direction.y != 0){
		float leftY = (AABB.leftY - ray.startPoint.y) / ray.direction.y;
		float rightY = (AABB.rightY - ray.startPoint.y) / ray.direction.y;
		maxInTime = max(min(leftY, rightY), maxInTime);
		minOutTime = min(max(leftY, rightY), minOutTime);
	}

	if(ray.direction.z != 0){
		float leftZ = (AABB.leftZ - ray.startPoint.z) / ray.direction.z;
		float rightZ = (AABB.rightZ - ray.startPoint.z) / ray.direction.z;
		maxInTime = max(min(leftZ, rightZ), maxInTime);
		minOutTime = min(max(leftZ, rightZ), minOutTime);
	}

	if(minOutTime < maxInTime){
		return false;
	}

	//直接用包围盒中点算可能会导致前面的mesh的AABB的depth反而比后面的大，导致被剔除
	if(maxInTime > ray.depth){
		return false;	//深度测试不通过
	}

	return true;
	

}

//返回碰撞点的mesh索引、三角形面片的第一个indicis索引，没碰撞到则不动
void hitMesh(inout Ray ray, uint meshIndex, inout ivec2 result){

	Mesh mesh = meshs[meshIndex];
	//因为我们的叶子场景只有一个mesh，所以能hitMesh检测说明一定能hitAABB
	//if(!hitAABB(mesh.AABB, ray)){
	//	return;
	//}

	uint startVertexIndex = mesh.indexInIndicesArray.x;
	uint endVertexIndex = mesh.indexInIndicesArray.y;
	 
	for(uint i = startVertexIndex; i < endVertexIndex; i += 3){
		vec3 P0 = vertices[indices[i]].pos.xyz;
		vec3 P1 = vertices[indices[i + 1]].pos.xyz;
		vec3 P2 = vertices[indices[i + 2]].pos.xyz;

		vec3 tangent = normalize(P1 - P0);
		vec3 bitangent = normalize(P2 - P0);
		vec3 normal = normalize(cross(tangent, bitangent));
		if(dot(normal, -ray.direction) < 0){
			continue;	//背面剔除
		}

		vec3 E1 = P1 - P0;
		vec3 E2 = P2 - P0;
		vec3 S = ray.startPoint - P0;
		vec3 S1 = cross(ray.direction, E2);
		vec3 S2 = cross(S, E1);

		vec3 tbb = 1 / dot(S1, E1) * vec3(dot(S2, E2), dot(S1, S), dot(S2, ray.direction));
		if(tbb.x > 0 && (1.0f - tbb.y - tbb.z) > 0 && tbb.y > 0 && tbb.z > 0){	//打到了
			if(tbb.x > ray.depth){
				continue;	//深度测试没通过
			}
			result = ivec2(meshIndex, indices[i]);
			ray.depth = tbb.x;
			return;
		}
	}

}

//由于不能使用递归，我们需要采用栈的方式循环读取
ivec2 hitScene(inout Ray ray){
	
	ivec2 result = ivec2(-1, -1);
	//栈的大小需要和和bvh树节点总数相同（最坏情况），应该从CPU中uniform过来的，但是懒得写了，直接用个大小为10的数组，对于我们这个小场景应该够用了
	//第一个表示sceneIndex，第二个是自身是哪个子树，第三个是父结点是否要去除
	ivec3 sceneStack[15] = ivec3[15](ivec3(0, 1, 1), ivec3(-1, -1, -1), ivec3(-1, -1, -1), ivec3(-1, -1, -1), ivec3(-1, -1, -1), ivec3(-1, -1, -1),
									 ivec3(-1, -1, -1), ivec3(-1, -1, -1), ivec3(-1, -1, -1), ivec3(-1, -1, -1), ivec3(-1, -1, -1), ivec3(-1, -1, -1),
									 ivec3(-1, -1, -1), ivec3(-1, -1, -1), ivec3(-1, -1, -1));
	int stackTop = 0;
	while(stackTop >= 0){

		if(sceneStack[stackTop].z == -1){	
			int isRight = sceneStack[stackTop].y;
			sceneStack[stackTop] = ivec3(-1, -1, -1);
			stackTop -= 1;
			if(isRight == 1){
				sceneStack[stackTop].z = -1;
			}
			continue;
		}

		BvhArrayNode scene = bvhArrayNode[sceneStack[stackTop].x];
		if(!hitAABB(scene.AABB, ray)){
			int isRight = sceneStack[stackTop].y;
			sceneStack[stackTop] = ivec3(-1, -1, -1);
			stackTop -= 1;
			if(isRight == 1){
				sceneStack[stackTop].z = -1;
			}
			continue;
		}

		//若是叶子节点，则直接进行mesh碰撞
		if(scene.leftNodeIndex == -1){
			hitMesh(ray, scene.meshIndex, result);
			int isRight = sceneStack[stackTop].y;
			sceneStack[stackTop] = ivec3(-1, -1, -1);
			stackTop -= 1;
			if(isRight == 1){
				sceneStack[stackTop].z = -1;
			}
			continue;
		}

		//先将左右子树压栈，先遍历左子树再右子树
		stackTop += 1;
		sceneStack[stackTop] = ivec3(scene.rightNodeIndex, 1, 1);
		stackTop += 1;
		sceneStack[stackTop] = ivec3(scene.leftNodeIndex, 0, 1);

	}

	return result;

}

//计算撞击点的irradiance到当前点的权重项fr * G = 1/2PI * costheta（这里只需要乘一个cos的原因是微分单元是dw，且均匀出射）
//现在先计算漫反射
float getWeight(vec3 currentPos, vec3 normal, vec3 hitPos, Material material){

	vec3 i = normalize(hitPos - currentPos);
	float costheta = dot(i, normal);	//max(dot(i, normal), 0.0f);

	return costheta / (2 * PI);		//fr = 1 / 2PI，均匀

}

//不应该通过shadowMap获得阴影，应该直接向光源发出射线，通过ray.depth来判断
//但是太卡了，还是用shadowMap吧
float getShadow(vec3 worldPos, vec3 lightPos){

	
	vec4 clipPos = lubo.proj * lubo.view * lubo.model * vec4(worldPos, 1.0f);
	vec3 ndcPos = clipPos.xyz / clipPos.w;
	vec2 uv = (ndcPos.xy * 0.5f + 0.5f);

	float depth = texture(shadowMap, uv).x;
	if(ndcPos.z + 0.001f < depth){
		return 1.0f;
	}
	return 0.0f;
	

	/*
	Ray ray;
	ray.startPoint = worldPos;
	ray.direction = normalize(lightPos - worldPos);
	ray.depth = 100.0f;
	
	hitScene(ray);
	return abs(ray.depth - length(lightPos - worldPos)) < 0.05f ? 1.0f : 0.0f;
	*/

}

int lightA = 36;
int sqrtLightA = 6;
//对于光源均匀求值，所以微分单元应该是dA，而pdf为1/A
//这里是在算撞击点接收到的光源的radiance
vec3 getRadianceFromLight(vec3 worldPos, vec3 normal, Material material){

	vec3 radiance = vec3(0.0f);

	vec3 lightPos = cubo.light.lightPos_strength.xyz;
	vec3 lightStrength = vec3(27.0f, 22.0f, 14.0f);
	vec3 lightNormal = normalize(cubo.light.normal_randomNumber.xyz);
	vec4 lightSize = cubo.light.size;

	//将面光源分为3x3的小点光源
	for(int i = 1; i < sqrtLightA * 2; i += 2){
		vec3 lightPointPos = lightPos + vec3(lightSize.x, 0.0f, 0.0f) * i / (sqrtLightA * 2);
		for(int j = 1; j < sqrtLightA * 2; j += 2){

			lightPointPos = lightPos + vec3(0.0f, 0.0f, lightSize.z) * j / (sqrtLightA * 2);
			vec3 Li = lightStrength / float(lightA);
			
			vec3 i = normalize(lightPointPos - worldPos);
			vec2 cosTheta = vec2(max(dot(-i, lightNormal), 0.0f), max(dot(i, normal), 0.0f));
			float distance = max(length(lightPointPos - worldPos), 1.0f);

			float G = cosTheta.x * cosTheta.y / (distance * distance);
			float fr = 1 / (2 * PI);
			float pdf = 1 / float(lightA);

			radiance += material.kd.rgb * Li * fr * G / pdf * getShadow(worldPos, lightPointPos), 0.0f;

		}
	}

	return radiance / float(lightA);

}

//计算撞击点的自发光
vec3 getRadianceFromHitPoint(Material material) {
	
	if(material.ke.rgb != vec3(0.0f)){
		return material.ke.rgb / float(lightA);	//场景就一个光源有自发光，所以写死9
	}
	return vec3(0.0f);
}

void getHitPointNormalAndTBN(int vertexIndex, inout vec3 normal, inout mat3 TBN){

	//计算面法线
	vec3 P0 = vertices[vertexIndex].pos.xyz;
	vec3 P1 = vertices[vertexIndex + 1].pos.xyz;
	vec3 P2 = vertices[vertexIndex + 2].pos.xyz;
	
	vec3 tangent = normalize(P1 - P0);
	vec3 bitangent = normalize(P2 - P0);
	normal = normalize(cross(tangent, bitangent));
	bitangent = normalize(cross(normal, tangent));
	TBN = mat3(tangent, bitangent, normal);
	
}

vec3 getOneSPP(Ray ray, uint randomNumberSeed){

	vec3 radiance = vec3(0.0f);
	mat3 TBN = mat3(1.0f);
	vec3 worldPos = vec3(1.0f);
	Material material;
	float pdf = 1.0f;
	float weight = 1.0f;
	float RR = 0.8f;	//轮盘赌概率

	ivec2 result = hitScene(ray);
	if(result.x == -1){
		return vec3(0.0f);
	}

	int meshIndex = result.x;
	int vertexIndex = result.y;
	worldPos = ray.startPoint + ray.depth * ray.direction;

	vec3 normal;
	getHitPointNormalAndTBN(vertexIndex, normal, TBN);	//计算面法线

	material = meshs[meshIndex].material;
	vec3 lightRadiance = getRadianceFromLight(worldPos, normal, material);	//发过来的radiance
	vec3 hitPointEmission = getRadianceFromHitPoint(material);
	vec3 irradiance = lightRadiance + hitPointEmission;
	weight *= getWeight(ray.startPoint, ray.normal, worldPos, material) / pdf;	//一开始RR = 1
	radiance += irradiance * weight;

	float randomNumber = rand(randomNumberSeed);
	randomNumber = smoothstep(0.0f, 1.0f, randomNumber);
	vec4 directionAndPdf = getRayDirection(material, TBN, randomNumber);
	pdf = directionAndPdf.w;

	if(rand(randomNumberSeed) > RR){
		return radiance;
	}

	ray.direction = normalize(directionAndPdf.xyz);
	ray.startPoint = worldPos + 0.01f * ray.direction;	//加一点bias，其实没啥用，但是心里感觉有用，加上吧，心里踏实
	ray.normal = normal;
	ray.depth = 100.0f;

	int lossNum = 0;
	int lossNumMax = 2;
	int maxShootNum = 16;
	while(maxShootNum > 0){
		
		lossNum = 0;
		ivec2 result = hitScene(ray);
		while(lossNum <= lossNumMax && result.x == -1){

			randomNumberSeed += lossNum * 100;
			float randomNumber = 0.8f * (float(lossNum) / float(lossNumMax)) + 0.2f * rand(randomNumberSeed);
			vec4 directionAndPdf = getRayDirection(material, TBN, randomNumber);	//每次rand后都会修改randomNumberSeed
			pdf = directionAndPdf.w;

			ray.startPoint = ray.startPoint - 0.01f * ray.direction + 0.01f * normalize(directionAndPdf.xyz);
			ray.direction = normalize(directionAndPdf.xyz);
			ray.depth = 100.0f;

			lossNum++;
			result = hitScene(ray);

		}
		if(lossNum - 1 == lossNumMax){
			return radiance;
		}

		int meshIndex = result.x;
		int vertexIndex = result.y;
		worldPos = ray.startPoint + ray.depth * ray.direction;

		vec3 normal;
		getHitPointNormalAndTBN(vertexIndex, normal, TBN);		//计算面法线

		material = meshs[meshIndex].material;
		vec3 lightRadiance = getRadianceFromLight(worldPos, normal, material);	//发过来的radiance
		vec3 hitPointEmission = getRadianceFromHitPoint(material);
		vec3 irradiance = lightRadiance + hitPointEmission;
		weight *= getWeight(ray.startPoint, ray.normal, worldPos, material) / pdf / RR;
		radiance += irradiance * weight;

		randomNumberSeed += maxShootNum * 1000;
		float randomNumber = rand(randomNumberSeed);
		randomNumber = smoothstep(0.0f, 1.0f, randomNumber);
		vec4 directionAndPdf = getRayDirection(material, TBN, randomNumber);
		pdf = directionAndPdf.w;

		if(rand(randomNumberSeed) > RR){
			return radiance;
		}

		ray.direction = normalize(directionAndPdf.xyz);
		ray.startPoint = worldPos + 0.01f * ray.direction;	//加一点bias，其实没啥用，但是心里感觉有用，加上吧，心里踏实
		ray.normal = normal;
		ray.depth = 100.0f;

		maxShootNum--;

	}

	return radiance;

}

void main(){

	vec3 radiance = vec3(0.0f);
	int sppNum = 9;
	vec2 texelSize = 1.0f / (gl_WorkGroupSize * gl_NumWorkGroups).xy;
	for(int i = 0; i < sppNum; i++){
	
		uvec2 seed2 = pcg2d(ivec2(gl_LocalInvocationIndex) * (i * 10 + sppNum * uint(floor(cubo.light.normal_randomNumber.w)) + 1));
		uint seed = seed2.x + seed2.y;
		vec2 texelUV = (vec2(gl_GlobalInvocationID.xy) + vec2(rand(seed), rand(seed))) * texelSize;
		Ray ray = makeStartRay(texelUV);
		radiance += getOneSPP(ray, seed);

	}

	radiance /= sppNum;
	imageStore(pathTracingResult, ivec2(gl_GlobalInvocationID.xy), vec4(radiance, 1.0f));

}


